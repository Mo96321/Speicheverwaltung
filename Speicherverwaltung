#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <signal.h>

// Constants
#define MEMORY_SIZE 1024
#define PARTITION_SIZE 128
#define NUM_PARTITIONS (MEMORY_SIZE / PARTITION_SIZE)

// Enums for management types and allocation types
typedef enum { STATIC, DYNAMIC, BUDDY } ManagementType;
typedef enum { FIRST_FIT, NEXT_FIT, BEST_FIT } AllocationType;

// Struct for memory blocks
typedef struct MemoryBlock {
    int size;
    struct MemoryBlock * next;
    
} MemoryBlock;

// Global variables
ManagementType management_type;
AllocationType allocation_type;
MemoryBlock* static_partitions[NUM_PARTITIONS];
int static_partition_usage[NUM_PARTITIONS];
MemoryBlock* dynamic_free_list;
MemoryBlock* dynamic_allocated_list;
MemoryBlock* buddy_free_list[10];
FILE* log_file = NULL;

// Signal handler for graceful termination
void handle_signal(int signal) {
    if (log_file) {
        fclose(log_file);
    }
    exit(EXIT_SUCCESS);
}

// Function to initialize static memory system
void initialize_static_system() {
    for (int i = 0; i < NUM_PARTITIONS; i++) {
        static_partitions[i] = malloc(PARTITION_SIZE);
        static_partition_usage[i] = 0;
    }
}

// Function to allocate static memory
void* allocate_static_memory(int size) {
    if (size > PARTITION_SIZE) {
        printf("Error:Angeforderte Größe zu groß für statische Partitionierung.\n");
        return NULL;
    }
    for (int i = 0; i < NUM_PARTITIONS; i++) {
        if (!static_partition_usage[i]) {
            static_partition_usage[i] = 1;
            if (log_file) {
                fprintf(log_file, "Allocated %d bytes in static partition %d\n", size, i);
            }
            return static_partitions[i];
        }
    }
    printf("Error: Keine freien statischen Partitionen verfügbar.\n");
    return NULL;
}

// Function to free static memory
void free_static_memory(void* ptr){
    for (int i = 0; i < NUM_PARTITIONS; i++) {
        if (static_partitions[i] == ptr) {
            static_partition_usage[i] = 0;
            if (log_file) {
                fprintf(log_file, "Statischen Speicher in der Partition freigegeben %d\n", i);
            }
            return;
        }
    }
    printf("Ungültige statische Speicheradresse.\n");
    
}

// Initialize dynamic memory system
void initialize_dynamic_system() {
    dynamic_free_list = malloc(sizeof(MemoryBlock));
    dynamic_free_list->size = MEMORY_SIZE;
    dynamic_free_list->next = NULL;
}

// Allocate dynamic memory using the selected allocation type
void * allocate_dynamic_memory(int size) {
    MemoryBlock *prev = NULL, *current = dynamic_free_list, *best_fit = NULL, *best_fit_prev = NULL;
    while (current) {
        if (current->size >= size) {
            if (allocation_type == FIRST_FIT) {
                break;
            } else if (allocation_type == BEST_FIT) {
                if (!best_fit || current->size < best_fit->size) {
                    best_fit = current;
                    best_fit_prev = prev;
                }
            }
        }
        prev = current;
        current = current->next;
    }
    if (allocation_type == BEST_FIT) {
        current = best_fit;
        prev = best_fit_prev;
    }
    if (!current || current->size < size) {
        printf("Error: Kein geeigneter Speicherblock gefunden.\n");
        return NULL;
    }
    if (current->size == size) {
        if (prev) {
            prev->next = current->next;
        } else {
            dynamic_free_list = current->next;
        }
    } else {
        MemoryBlock *new_block = (MemoryBlock *)((char *)current + size);
        new_block->size = current->size - size;
        new_block->next = current->next;
        if (prev) {
            prev->next = new_block;
        } else {
            dynamic_free_list = new_block;
        }
        current->size = size;
    }
    current->next = dynamic_allocated_list;
    dynamic_allocated_list = current;
    if (log_file) {
        fprintf(log_file, "Allocated %d bytes dynamically\n", size);
    }
    return (void *)(current + 1);
}

// Free dynamic memory
void free_dynamic_memory(void* ptr){
    MemoryBlock* block= (MemoryBlock*)ptr-1;
    block->next=dynamic_free_list;
    dynamic_free_list=block;
    if(log_file){
        fprintf(log_file, "Freigegebener dynamischer Speicherblock der Größe %d\n",block->size);

    }
}

// Initialize buddy memory system
void initialize_buddy_system(){
    for(int i = 0; i<10;i++){
        buddy_free_list[i]= NULL;
    }
buddy_free_list[9]= malloc(sizeof(MemoryBlock));
buddy_free_list[9]->size=MEMORY_SIZE;
buddy_free_list[9]->next=NULL;

}

// Allocate buddy memory
void* allocate_buddy_memory(int size) {
    int order = 0;
    while ((1 << order) < size) order++;
    if (order > 9) {
        printf("Error: Gewünschte Größe zu groß für das Buddy-System.\n");
        return NULL;
    }
    for (int i = order; i < 10; i++) {
        if (buddy_free_list[i]) {
            MemoryBlock* block = buddy_free_list[i];
            buddy_free_list[i] = block->next;
            while (i > order) {
                i--;
                MemoryBlock* buddy = (MemoryBlock*)((char*)block + (1 << i));
                buddy->size = 1 << i;
                buddy->next = buddy_free_list[i];
                buddy_free_list[i] = buddy;
            }
            block->next = NULL;
            if (log_file) {
                fprintf(log_file, "Allocated %d Bytes unter Verwendung des Buddy-Systems\n", size);
            }
            return (void*)(block + 1);
        }
    }
    printf("Error: Kein geeigneter Buddy-Block gefunden.\n");
}


// Free buddy memory
void free_buddy_memory(void* ptr) {
    MemoryBlock* block = (MemoryBlock*)ptr - 1;
    int order = 0;
    while ((1 << order) < block->size) order++;
    block->next = buddy_free_list[order];
    buddy_free_list[order] = block;
    if (log_file) {
        fprintf(log_file, "Freigegebener Buddy-Speicherblock der Größe %d\n", block->size);
    }
}



// Evaluate efficiency of memory management
void evaluate_efficiency() {
    int internal_fragmentation = 0;
    int external_fragmentation = 0;
    switch (management_type) {
        case STATIC:
            for (int i = 0; i < NUM_PARTITIONS; i++) {
                if (static_partition_usage[i]) {
                    internal_fragmentation += PARTITION_SIZE - static_partitions[i]->size;
                } else {
                    external_fragmentation += PARTITION_SIZE;
                }
            }
            break;
        case DYNAMIC:
            for (MemoryBlock* block = dynamic_allocated_list; block != NULL; block = block->next) {
                internal_fragmentation += block->size;
            }
            for (MemoryBlock* block = dynamic_free_list; block != NULL; block = block->next) {
                external_fragmentation += block->size;
            }
            break;
        case BUDDY:
            for (int i = 0; i < 10; i++) {
                for (MemoryBlock* block = buddy_free_list[i]; block != NULL; block = block->next) {
                    external_fragmentation += block->size;
                }
            }
            break;
    }
    printf("Interne Fragmentierung: %d bytes\n", internal_fragmentation);
    printf("Externe Fragmentierung: %d bytes\n", external_fragmentation);
}


//Function to parse command line arguments
void parse_arguments(int argc, char* argv[]) {
    for (int i = 1; i < argc; i++) {
        if (strcmp(argv[i], "-Speicherverwaltung C") == 0 && i + 1 < argc) {
            if (strcmp(argv[i + 1], "static") == 0) {
                management_type = STATIC;
            } else if (strcmp(argv[i + 1], "dynamic") == 0) {
                 management_type = DYNAMIC;
            } else if (strcmp(argv[i + 1], "Buddy") == 0) {
                 management_type = BUDDY;
        } else {
            printf("Error: Ungültiger Speicherverwaltungstyp.\n");
            exit(EXIT_FAILURE);
        }
        i++;
        } else if (strcmp(argv[i], "-konzept") == 0 && i + 1 < argc) {
            if (strcmp(argv[i + 1], "first") == 0) {
                allocation_type = FIRST_FIT;
            } else if (strcmp(argv[i + 1], "next") == 0) {
                allocation_type = NEXT_FIT;
            } else if (strcmp(argv[i + 1], "best") == 0) {
                allocation_type = BEST_FIT;
            } else {
                printf("Error: Ungültiges Zuteilungskonzept.\n");
                exit(EXIT_FAILURE);
            }
            i++;
        } else if (strcmp(argv[i], "-logdatei") == 0 && i + 1 < argc) {
            log_file = fopen(argv[i + 1], "w");
            if (!log_file) {
                printf("Error: Log-Datei konnte nicht geöffnet werden.\n");
                exit(EXIT_FAILURE);
            }
            i++;
        } else {
            printf("Ungültiges Befehlszeilenargument.\n");
            exit(EXIT_FAILURE);
        }
    }
}


// Function to handle user input interactively
void handle_user_input() {
    while (1) {
        printf("Geben Sie Befehl ein (allocate <Größe> / free <Adresse> / Beenden): ");
        char command[10];
        int size;
        void* address;
        scanf("%s", command);
        if (strcmp(command, "allocate") == 0) {
            scanf("%d", &size);
            void* ptr = NULL;
            switch (management_type) {
                case STATIC:
                    ptr = allocate_static_memory(size);
                    break;
                case DYNAMIC:
                    ptr = allocate_dynamic_memory(size);
                    break;
                case BUDDY:
                    ptr = allocate_buddy_memory(size);
                    break;
            }
            printf("Allocated at address: %p\n", ptr);
        } else if (strcmp(command, "free") == 0) {
            scanf("%p", &address);
            switch (management_type) {
                case STATIC:
                    free_static_memory(address);
                    break;
                case DYNAMIC:
                    free_dynamic_memory(address);
                    break;
                case BUDDY:
                    free_buddy_memory(address);
                    break;
            }
        printf("Speicher bei Adresse freigegeben: %p\n", address);
        } else if (strcmp(command, "Beenden") == 0) {
        break;
        } else {
        printf("Error: Ungültiger Befehl.\n");
        }
    }
}



// Main function
int main(int argc, char* argv[]) {
    signal(SIGINT, handle_signal);
    parse_arguments(argc, argv);
    switch (management_type) {
        case STATIC:
            initialize_static_system();
            break;
        case DYNAMIC:
            initialize_dynamic_system();
            break;
        case BUDDY:
            initialize_buddy_system();
            break;
    }
    handle_user_input();
    evaluate_efficiency();
    if (log_file) {
        fclose(log_file);
    }
    return 0;
}











